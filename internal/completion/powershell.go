package completion

// PowerShell returns the PowerShell completion script for witr.
func PowerShell() string {
	// Note: Using [char]10 instead of backtick-n for newlines since Go raw strings can't contain backticks
	return `# witr PowerShell completion
# Generated by: witr completion powershell

Register-ArgumentCompleter -Native -CommandName witr -ScriptBlock {
    param($wordToComplete, $commandAst, $cursorPosition)

    $commands = @('completion')
    $shells = @('bash', 'zsh', 'fish', 'powershell', 'pwsh')
    $flags = @(
        @{Name='--pid'; Description='Explain a specific PID'; TakesArg=$true}
        @{Name='--port'; Description='Explain port usage'; TakesArg=$true}
        @{Name='--short'; Description='One-line summary'; TakesArg=$false}
        @{Name='--tree'; Description='Show full process ancestry tree'; TakesArg=$false}
        @{Name='--json'; Description='Output result as JSON'; TakesArg=$false}
        @{Name='--warnings'; Description='Show only warnings'; TakesArg=$false}
        @{Name='--no-color'; Description='Disable colorized output'; TakesArg=$false}
        @{Name='--env'; Description='Show only environment variables'; TakesArg=$false}
        @{Name='--help'; Description='Show help message'; TakesArg=$false}
        @{Name='--version'; Description='Show version and exit'; TakesArg=$false}
    )

    $elements = $commandAst.CommandElements
    $elementCount = $elements.Count

    # Handle completion subcommand
    if ($elementCount -ge 2 -and $elements[1].Extent.Text -eq 'completion') {
        if ($elementCount -eq 2 -or ($elementCount -eq 3 -and $wordToComplete)) {
            $shells | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', "Generate $_ completion script")
            }
            return
        }
        return
    }

    # Handle flag arguments
    if ($elementCount -ge 2) {
        $prevElement = $elements[-1].Extent.Text
        if (-not $wordToComplete) {
            $prevElement = $elements[-1].Extent.Text
        } elseif ($elementCount -ge 3) {
            $prevElement = $elements[-2].Extent.Text
        }

        if ($prevElement -eq '--pid') {
            $pids = witr __complete pids 2>$null
            if ($pids) {
                $pids -split [char]10 | Where-Object { $_ -like "$wordToComplete*" } |
                    Select-Object -First 50 | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', "PID $_")
                }
            }
            return
        }

        if ($prevElement -eq '--port') {
            $ports = witr __complete ports 2>$null
            if ($ports) {
                $ports -split [char]10 | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', "Port $_")
                }
            }
            return
        }
    }

    # Flag completion
    if ($wordToComplete -like '-*') {
        $flags | Where-Object { $_.Name -like "$wordToComplete*" } | ForEach-Object {
            [System.Management.Automation.CompletionResult]::new($_.Name, $_.Name, 'ParameterName', $_.Description)
        }
        return
    }

    # First argument: subcommand or process name
    if ($elementCount -eq 1 -or ($elementCount -eq 2 -and $wordToComplete -and $wordToComplete -notlike '-*')) {
        # Offer completion subcommand
        $commands | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
            [System.Management.Automation.CompletionResult]::new($_, $_, 'Command', 'Generate shell completion scripts')
        }

        # Offer process names
        $procs = witr __complete processes 2>$null
        if ($procs) {
            $procs -split [char]10 | Where-Object { $_ -like "$wordToComplete*" } |
                Select-Object -First 50 | ForEach-Object {
                [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', "Process: $_")
            }
        }
        return
    }

    # Default: offer process names
    $procs = witr __complete processes 2>$null
    if ($procs) {
        $procs -split [char]10 | Where-Object { $_ -like "$wordToComplete*" } |
            Select-Object -First 50 | ForEach-Object {
            [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', "Process: $_")
        }
    }
}
`
}
